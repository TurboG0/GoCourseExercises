Lecture Arrays:

if you initialize array like this: b := [...]string {"Saba", "Gela"}
compiler will guess how many values are there in the array with ... inside []
this is called literall

if arrays are different type like if one is string and other int or
if one of them is [2]int and other [3]int you can't use = operator on them

for example if array c %T is [4]int and array a %T is [3]int 
i can't do operation like c = a or vice versa

------------------------------------------------------------------
Lecture Slice:
you can add elements into slice using append function and inside 
append function you can add as many arguments as you want
for example: mySlice = append(mySlice, arg1, arg2, arg3, arg4 ...)

you delete element in slice also using append function and reslicing 
method
for example:
    a := []int {1, 2, 3, 4, 5}
    if i want to delete first element i will write
    a = append(a[:0], a[1:]...)

slice is built on top of array. Could be said that it is slice is referencing
its values
In internal of GO values are stored inside of an underlying array.
Slice is pointing towards that underlaying array. There is pointer
that says go look at that underlying array, that memory address where
those values are store and then geet the values from there.
Slice is struct. data structure for slice is pointer and it is writen
like this. 
type slice struct {
    array unsafe.Pointer
    len int
    cap int 
}

everytime we use make it is allocating memory in heap. make is type 
and unlike new, make return type is the same as the type of its 
argument not a pointer to it

if i have slice a and i type something like b := a
b is pointing to underlying array that a slice has so any modification
on those array from either slice(variable) will cause change for both
slice(variable). in order for that to not happen use function
copy(destination, source)
for example:
    a := []int{1, 2, 3, 4, 5}
    b := make([]int, 5)
    copy(b, a)

what is copy pointing towards??
    
-------------------------------------------------------------------
maps
if you want to delete from map we need to use 
func delete(map, key)

tu mapidan iseti elemntis washal sheecdebi romelic ar arsebobs an ramdenime
xnis win washale, aranairi errori ar moxdeba da compileri ar chavardeba
panikashi da ar getyvis ras aketeb shig ho ar gaqo mokled

tu mapis value aris int da key ar arsebobs is 0-s daabrunebs

comma okay idiom
--------------------------------------------------------------------
Functions

tip: if you are comming for other languages such as me from c++
drop terminology like pass by value pass by reference
when you pass a value as an argument to a function, it's going to assign
that value to a variable, to an identifier. argument is passed
by value

if i want to create function with unlimited parameter it should look
something like this:
func sum(ii ...int){} 
if you use %T on argument that is passed in this function you will 
see that it is actually slice of int []int. search Variadic with
ctrl + f inside go doc to see more
this variadic parameter ... needs to be last obviously. you can pass
other arguments normally if you like behind variadic parameter
Note: variadic parameter ... also accepts 0 parameters


defer statement doesn't run the function till the outer surrounding 
function exits and does it's thing

when you write identifie for function for example
func (p Person) speak() it almost adds it in that struct like
this function was written inside that Person struct like you write
methods in c++ and other oop languages. so if i want to call that func
i will call it like p.speak() and not just speak(). If function has
reciever it is called method.

Interfaces allow us to have polymorphysm which means that one value,
which is of a certain type, can also be of another type

Interface rizz be like: hey babe if you got these methods you are my type

Stringer interfece be working like:
any type that has method with returns string eg
type Stringer interface {
    String() string
}
is stringer
if you want to adjust how the default printin is of stuff,
you can implement the stringer interface


wrapper is a function that provides and additional layer
of abstraction of functionality around an existing function or
method. it allows you to modify inputs, outpus, or behaviour
of funciton without directly modifying it

we also have writer interface. any type that implemets this method
Write(p []byte) (n int, err error) is a Writer interface
writer interface looks like this:
type Writer interface {
    Write(p []byte) (n int, err error)
}

creating files be like:
first of all we need "os" package to be included
to create file i need to use os.Create("file.txt") function:
os.Create("output.txt") which returns file and error
in order to writen in file i need:
Write(b []byte) function which returns int and error

what is the difference between string and slice of bytes?
first of all they are different types, but they are closely related
and can often be converted betweem each other
A string in go represents a sequence of characters. it is an
immutable type, which means you can't modify individual characters
inside string. string values are always interpreted as UTF-8 
encoded Unicode text.
[]byte is slice of bytes, where each element represents single byte.
It is mutable type, so you can modify individual bytes within a byte
slice. It can be used to represent binary data or text in various
encoding
examples of converting these types
string to a byte slice:
bytes := []byte(str)
byte slice to a string
str := string(bytes)
IMPORTENT:converting between strings and byte slices involves encoding
and decoding operations, which can indroduce potential errors if encoding
is not handeled correctly. be maindful of the encoding.

byte buffer is a region of memory used to temporarily store a 
sequence of bytes. it is useful for tasks like 
data serialization, network communication, file I\O, and efficient
string manipulation.
A byte buffer is a data structure that provides a convenient interface
to manipulate sequences of byte efficiently. It serves a a temporary
storage for byte data and enables operations such as reading, writing,
appending, and resizing byte sequences.
(Find more info on this from course outline from page 75 +-2)
if you want to create buffer you do that like this:
b := bytes.NewBufferString("Hello")
if you want to print that buffer you do this:
fmt.Println(b.String())
if you want to write in buffer you use this function:
b.WriteString("Ghopers!")
if you want to reset buffer you use this function:
b.Reset()
you can write in buffer also like this:
b.Write([]byte("happy happy haaapppyyy"))
buffer implements the writer interface

NOTE: Functions are type in go meaning we can assign functions to
variables

we can return functions and we can pass funtcion as an argument

Callback is when you pass function as an argument

Hands-on-Exercise #67 return to this every day and try to rewrtire
code that is in it


why do we use anonymous functions. what is the main reason for it?
Anonymous funcs are commonly used when you want to pass a function 
as an argument to another function or when you need to 
define a short-lived function for a specific task.