 ****************************************************************
 * PRACTICE MAKES PROGRESS. REPETITION IS THE MOTHER OF MASTERY *
 *      PERSISTENTLY PATIENTLY YOU ARE BOUND TO SUCCEED         *
 ****************************************************************

Lecture Arrays:

if you initialize array like this: b := [...]string {"Saba", "Gela"}
compiler will guess how many values are there in the array with ... inside []
this is called literall

if arrays are different type like if one is string and other int or
if one of them is [2]int and other [3]int you can't use = operator on them

for example if array c %T is [4]int and array a %T is [3]int 
i can't do operation like c = a or vice versa

------------------------------------------------------------------
Lecture Slice:
you can add elements into slice using append function and inside 
append function you can add as many arguments as you want
for example: mySlice = append(mySlice, arg1, arg2, arg3, arg4 ...)

you delete element in slice also using append function and reslicing 
method
for example:
    a := []int {1, 2, 3, 4, 5}
    if i want to delete first element i will write
    a = append(a[:0], a[1:]...)

slice is built on top of array. Could be said that it is slice is referencing
its values
In internal of GO values are stored inside of an underlying array.
Slice is pointing towards that underlaying array. There is pointer
that says go look at that underlying array, that memory address where
those values are store and then geet the values from there.
Slice is struct. data structure for slice is pointer and it is writen
like this. 
type slice struct {
    array unsafe.Pointer
    len int
    cap int 
}

everytime we use make it is allocating memory in heap. make is type 
and unlike new, make return type is the same as the type of its 
argument not a pointer to it

if i have slice a and i type something like b := a
b is pointing to underlying array that a slice has so any modification
on those array from either slice(variable) will cause change for both
slice(variable). in order for that to not happen use function
copy(destination, source)
for example:
    a := []int{1, 2, 3, 4, 5}
    b := make([]int, 5)
    copy(b, a)

what is copy pointing towards??
    
-------------------------------------------------------------------
maps
if you want to delete from map we need to use 
func delete(map, key)

tu mapidan iseti elemntis washal sheecdebi romelic ar arsebobs an ramdenime
xnis win washale, aranairi errori ar moxdeba da compileri ar chavardeba
panikashi da ar getyvis ras aketeb shig ho ar gaqo mokled

tu mapis value aris int da key ar arsebobs is 0-s daabrunebs

comma okay idiom
--------------------------------------------------------------------
Functions

tip: if you are comming for other languages such as me from c++
drop terminology like pass by value pass by reference
when you pass a value as an argument to a function, it's going to assign
that value to a variable, to an identifier. argument is passed
by value

if i want to create function with unlimited parameter it should look
something like this:
func sum(ii ...int){} 
if you use %T on argument that is passed in this function you will 
see that it is actually slice of int []int. search Variadic with
ctrl + f inside go doc to see more
this variadic parameter ... needs to be last obviously. you can pass
other arguments normally if you like behind variadic parameter
Note: variadic parameter ... also accepts 0 parameters


defer statement doesn't run the function till the outer surrounding 
function exits and does it's thing

when you write identifie for function for example
func (p Person) speak() it almost adds it in that struct like
this function was written inside that Person struct like you write
methods in c++ and other oop languages. so if i want to call that func
i will call it like p.speak() and not just speak(). If function has
reciever it is called method.

Interfaces allow us to have polymorphysm which means that one value,
which is of a certain type, can also be of another type

Interface rizz be like: hey babe if you got these methods you are my type

Stringer interfece be working like:
any type that has method with returns string eg
type Stringer interface {
    String() string
}
is stringer
if you want to adjust how the default printin is of stuff,
you can implement the stringer interface


wrapper is a function that provides and additional layer
of abstraction of functionality around an existing function or
method. it allows you to modify inputs, outpus, or behaviour
of funciton without directly modifying it

we also have writer interface. any type that implemets this method
Write(p []byte) (n int, err error) is a Writer interface
writer interface looks like this:
type Writer interface {
    Write(p []byte) (n int, err error)
}

creating files be like:
first of all we need "os" package to be included
to create file i need to use os.Create("file.txt") function:
os.Create("output.txt") which returns file and error
in order to writen in file i need:
Write(b []byte) function which returns int and error

what is the difference between string and slice of bytes?
first of all they are different types, but they are closely related
and can often be converted betweem each other
A string in go represents a sequence of characters. it is an
immutable type, which means you can't modify individual characters
inside string. string values are always interpreted as UTF-8 
encoded Unicode text.
[]byte is slice of bytes, where each element represents single byte.
It is mutable type, so you can modify individual bytes within a byte
slice. It can be used to represent binary data or text in various
encoding
examples of converting these types
string to a byte slice:
bytes := []byte(str)
byte slice to a string
str := string(bytes)
IMPORTENT:converting between strings and byte slices involves encoding
and decoding operations, which can indroduce potential errors if encoding
is not handeled correctly. be maindful of the encoding.

byte buffer is a region of memory used to temporarily store a 
sequence of bytes. it is useful for tasks like 
data serialization, network communication, file I\O, and efficient
string manipulation.
A byte buffer is a data structure that provides a convenient interface
to manipulate sequences of byte efficiently. It serves a a temporary
storage for byte data and enables operations such as reading, writing,
appending, and resizing byte sequences.
(Find more info on this from course outline from page 75 +-2)
if you want to create buffer you do that like this:
b := bytes.NewBufferString("Hello")
if you want to print that buffer you do this:
fmt.Println(b.String())
if you want to write in buffer you use this function:
b.WriteString("Ghopers!")
if you want to reset buffer you use this function:
b.Reset()
you can write in buffer also like this:
b.Write([]byte("happy happy haaapppyyy"))
buffer implements the writer interface

NOTE: Functions are type in go meaning we can assign functions to
variables

we can return functions and we can pass funtcion as an argument

Callback is when you pass function as an argument

Hands-on-Exercise #67 return to this every day and try to rewrtire
code that is in it


why do we use anonymous functions. what is the main reason for it?
Anonymous funcs are commonly used when you want to pass a function 
as an argument to another function or when you need to 
define a short-lived function for a specific task.

-----------------------------------------------------------------------
//es da zemot funqciebi unda wavikitxo yovel dge rata kargad gajdes tvinshi

Pointers

In Go reference type is pointer
Go has several reference types which are: pointers, slices, maps,
functions, interfaces and channels

NOTE: when you assign a reference type to another variable, the new variable references the same memory location

In Go, all data is passed by value, which means that whenever you pass data to a function, Go
creates a copy of that data and assigns the copy to a parameter variable. The function can do
whatever it wants to the copy without affecting the original data

A mutable value is a value that can be changed. In Go, slices, maps, and pointers are
mutable data types. Even though they are passed by value, they still behave as if they were
passed by reference because the "value" that is copied and passed is the reference to the
underlying data, not the actual data in case of slice it is underlaying array

Since everything in Go is passed as a value pointer is also passed as a value and is no exception to the rule. This means that function get copy of the address. Therefore, dereferencing the pointer and
modifying the value it points to inside the function will modify the original value.

In summary, in Go, everything is passed by value. However, for mutable data types, the
"value" that's passed includes a reference to the underlying data, which is why changes
made inside the function are visible outside of it.

Pointer and value semantics
Pointer semantics in Go, involve passing the memory address (a "pointer")
rather than the data itself. This means that you can modify the original data, not just a copy of
it

Value semantics are simpler and often safer because they avoid side effects, but
they can be inefficient for large data structures because they involve copying data

GUIDELINES to follow whether to use pointer or value semantics

1.Use Value Semantics When Possible:
● Value semantics are simpler and usually safer, since they don't involve shared state
or require you to think about memory management.

● rule of thumb, if a function doesn't need to modify its input, or the data you're working
with is small (like built-in types or small structs), use value semantics. s

● rule of thumb: use value semantics for builtin types (numeric, string, bool) and

reference types (slices, maps, channels, pointer, interfaces, functions)

2. Use Pointer Semantics for Large Data:
● Copying large structs or arrays can be inefficient.

● If the data you're working with is large, you might want to use pointer semantics to
avoid the cost of copying the data. A rule of thumb: 64 bytes or larger, use pointers.

3. Use Pointer Semantics for Mutability:
● If a function or method needs to modify its receiver or an input parameter, you'll need
to use pointer semantics.

● This is a common use case for methods that need to update the state of a struct.

4. Consistency:
● It's important to be consistent. If some functions on a type use pointer semantics and
others use value semantics, it can lead to confusion. Typically, once a type has a
method with pointer semantics, all methods on that type should have pointer
semantics.

5. Pointer Semantics When Interfacing With Other Code:
● If you're interfacing with other code (like a library or a system call), you might need to
use pointer semantics. For example, the `json.Unmarshal` function in the Go standard
library requires a pointer to a value to populate it with unmarshalled data

VALUE SEMANTICS
value semantics facilitate higher levels of integrity
"the majority of bugs that we get in software have to do with the
mutation of memory" ~ Bill Kennedy
everybody gets their own copy of the data (pass by value) helps
keep data bug free
● if everybody is isolated to their own copy of the data (pass
by value) then the bug is isolated to that one piece of code
○ value semantics also reduce side-effects around concurrency
○ more likely to keep values on the stack
○ you can have methods that use pointers if there's some form of unmarshaling
going on

POINTER SEMANTICS
you don’t want to pass around a lot of data
you want to change the data at a location (mutability)

Remember: the decision of using pointer or value semantics should be more about
sharing and mutating state rather than memory allocation and performance

The idea of the method set is integral to how interfaces are implemented and used in Go.
An interface in Go defines a method set, and any type whose method set is a superset of the
interface's method set is considered to implement that interface
if you define a method with a pointer receiver, the
method is only in the method set of the pointer type. This is important in the context of
interfaces because if an interface requires a method that's defined on the pointer (not the
value), then you can only use a pointer to that type to satisfy the interface, not a value of the
type.

questions I need to answert to provet to my self that I understand these concepts
1. In go what is referece type? list the reference types
2. What happens when you assign a reference type to another variable?
3. In Go how is data passed? and what does it do
4. What is mutable value ? list mutable data types. how do this data types behave when they are passed?
5. when pointer is passed in functoin how is it passed and what does the function get? what will happen to original value if i modify pointer inside the function?
6. Describe Pointer and Value semantics
7. What are the GUIDELINES of using either Pointer or Value semantics?
8. What are rule of thumb of using Value semantics?
9. Which semantic do I need to use when i'm interfecing with other code?
and what does interfecing with other code mean?
10. Benefits of using Value Semantics and Pointer Semantics.
11. when making decision on which semantic to use what should i remember?
12. Which semantic kinda has to be default? and why
13. If i use pointer semantics what are values more likely to do ?
14. What command or so to say flag can i use to check whether value escpaes heap or not?
15. What are method sets and why are they important?
answer these question every day till I go to Germany.
Read Pointer section at least 3 times in couser_outline folder.
Look into Follow-Lecture -> pointers -> method-sets dir pretty important stuff is written there about method-sets
--------------------------------------------------------------------------
Generics:

Generics allow us to abstract our code and make it more DRY(Do not Repeat Yourself)

syntax for creating generic function of type T that accepts values i want
in this case int and float64
func addT[T int | float64](){

}

type set interface allows us to abstract our generic functions even more eg 
type mynumbers interface {
	int | float64
}

// abstract previously ussed addT function with interface
func addT[T mynumbers](a, b T) T {
	return a + b
}

Type alliases and underlying type constraints

if i add ~ behind the type for example int it tells compiler to include all values of that type in my example of type int
type mynumbers interface {
	~int | ~float64
}

// abstract previously ussed addT function with interface
func addT[T mynumbers](a, b T) T {
	return a + b
}

type myAlias int

func main() {
	var n myAlias = 22
	fmt.Println(addT(n, 2))
	fmt.Println(addT(1.2, 2.2))
}
this won't work without ~int inside myNumbers interface

package constraint

comparable is any type that can be compared like int, boolean, string etc


concrete type vs interface type

what is concrete type ?
concrete type is a type that you can directly instantie or create from. This means that type can directly represent a set of values and that you can create an instance of this type without any additional information.
concrete type examples: int, bool, string, float64, slices, maps, structs

interface type is abstract. they represent behaviour or type but not a specific set of values
------------------------------------------------------------------------
Json
cool websites:
https://rawgit.com
https://mholt.github.io/json-to-go/
godoc.org   // check this out and try to understand code that is written behing the function like fmt.Println and function I use from go standard library in general. Check indexes in Package io and stuff like that

use marshal to turn your data into json and use unmarshal to 
use that data into Go or any language

Need to find out about Encode and Decode

Writer interface is real important shit
if i have Writer interface i can pass that to NewEncode function which
give me pointer to Encoder *Encoder. I can then use that *Encoder
to Encode shit

Reader interface is also important shit

Learn about Sort interface from godoc

for sorting stuff just check directory inside 
Follow-Lecture > Json > sort or customSort

bcrypt
is an excellent way to store a password information. as soon as u get user password u encrypt it with bcrypt and even you don't know what the password is. Generally you never store password you only store encrypted version of it.
inside go docs you can search bcrypt

--------------------------------------------------------------------
Concurrency

Concurency is a design pattern which allows code to run in parrarel. It's a way that you could write your code. Concurency which is a design pattern doesn't guarantee that your code will run parrarel.

WaitGroup
to make go routines work we have to use some form of syncronization.
We have to tell our code to wait so entry point function main() doesn't finish it's execution before go routine starts running.

we have function called func (wg *WaitGroup) Add(delta int)
this function waits for n amount of things, n being integer argument you pass yo Add function
we also need func (wg *WaitGroup) Wait() and  func (wg *WaitGroup) Done() functions. read about these in godoc.org/sync and read godoc.org/runtime. Be sure that I understand methodsets at this point.

IMPORTANT: "The method set of a type determine the interfaces that the type implements and the methods that can be called using a receiver of that type"
    A NON-POINTER RECEIVER works with values that are POINTERS or NON-POINTERS
    A POINTER RECEIVER only works with values that are POINTERS

Read effective go documentation on concurrency
    "Do not communicate by sharing memory. instead share memory by communicating"

Only one goroutine has access to the value at any given time. Data races cannot occur, by design.

 A goroutine has a simple model: it is a function executing concurrently with other goroutines in the same address space
 what does it mean to execute in the same address space as something else?

 Race condition
go run -race . checks for race conditions and runs go
but it needs gcc to be installed in order for it to work

 first of all use mutex to lock down code to avoid Race conditions
 for that we will need to create var mu sync.Mutex and use function
 like mu.Lock() and mu.Unlock() and place code in between them which reads value and writes in it. THere is alwa RWMutex that gives more flexibility. allows unlimited Reads

 Atomic
 with atomics i have to use int64 variables
 func AddInt64(addr *int64, delta int64) (new int64)
 AddInt64 atomically adds delta to *addr and returns the new value
 to read from atomic use func LoadInt64(addr *int64) (val int64)

  Except for special, low-level applications, synchronization is better done with channels or the facilities of the sync package.
  init order to print out from atomic i need atomic.LoadInt64(&v)
-----------------------------------------------------------------
Channels
Channels are higher level order way, a better way for synchronizing your code and writing concurrent code

to make channel
    c := make(chan int) obviously we are putting integers in this channel

    c <- 42     this puts number 42 inside channel
    fmt.Prinln(<-c)     will print that value

the code above won't run. This will give error all go routines are asleep. Deadlock. And that's because channels  blocked. When you send and receive on a channel, it's like relay racers, racers in a track race. Runners have to pass a baton and they have to pass it hand to hand. Transaction cannot occure because until both send and receive can happen at the same time. If they can't happen at the same time, it blocks the send and receive blocks until the receiver is ready to pull it off.

channels block
channels block 
channels block
channels block
channels block

so how do we fix code above?

c := make(chan int)

go func () {
    c <- 42
}()
fmt.Println(<-c)

so what is happening here?
this 42 is getting put into channel. c <- 42 blocks it in go routine. But because this go routine has just been sent off to run on its own, the other go routine, the main go routine comes down here, fires off this one, and then the flow continues it.
then it comes down to fmt.Println(<-c) and that <-c blocks until it takes the value off. And then so this one's over there ready to put it on that one down here


this is buffer channel
c := make(chan int, 1)
buffe channel is a channle that will allow certain values to sit in that channel regardless of whether or not something's ready to pull it off. And so I can say, okay, my buffer channel will allow one to sit in there. Here my channel is going to allow 1 value to sit in there. 

try to stay away from buffer channels
try to stay away from buffer channels

channels are runners in a relay race
    they are synchronized
    they have to pass/receive the value at the same time
        just like runners in a relay race have to pass / receive the
        baton to each other at the same time
            one runner can't pass the baton at one moment
            and then laterr have the other runner receive the baton
            the baton is passed/received by the runners at the same time
        the values is passed/received synchronously; at the same time

the channels in above examples are biderectional chanels because in those channels we are both able to send on to the channel and we are able to receive from that channel

to make one directional chanel that you only will be able to send values on to you need to do this:
c := make(chan <- int)

to make one directional chanel that you only will be able to receive values onto you need to do this:
c := make(<-chan int)

c := make(chan int) // type is chan int
cr := make(<-chan, int) // type is <-chan int
cs := make(chan<-, int) // type is chan<- int

specific to general doesn't assign 
c = cr // doesn't work
c = cs // doesn't work

general to specific assigns
cr = c
cs = c

general to specific converts
(<-chan int)(c)
(chan<- int)(c)

specific to general doesn't work
(chan int)(cr)
(chan int)(cs)

so rule of thumb: from specific to general doesn't work
                  from general to specific does work


in funcs you can specify
    receive channel
        you can receive values from the channel
        a receive channel parameter
        in the func, you can only pull values from the channel
    send channel
        you can push values to the channel
        you can't receive/pull/read from channel
        you can only push values to channel

when using chanels it's better to create dual chanel and then decide whether it is going to be reiceiver or sender inside function


when you are done using chanel use close(c) function where c in this function is channel. this function closes primary channel

range over channel
range loop pulls off of a channel until the channel is closed and it just is there pulling, waiting to pull until it is closed. And when the channel is close, it pull any last value or values that are still on the channel. this is the reason why we need to close channel after we are done with it

select statement is going to look which are the channels that it can pull value off of. 

Comma ok idiom



Fan in Pattern.
Fan in is common desgin pattern because it's like, okay, I have a chunk of work I don't know how much it's gonna be. Let's fan that out to as many go routines as possible. They will all be working on that as much as  they can, and then when they get results, we will fan those results back into another channel and we'll get a channel with just the resutls.

Fan out Pattern.
When you fan out you are taking like a piece of work. Llets say i have something that needs to be done over and over and over again many times, like encoding videos and I have a proccess that runs for encoding videos and i have 1000videos that need to be encoded. I can say hey encode these videos and for each of these videos run go routine and launch all 1000 go routines encode them at the same time take results and bring it back. we can also throtle this meaning I can say that I only want to encode 10 videos at a time instead of 1000
