 ****************************************************************
 * PRACTICE MAKES PROGRESS. REPETITION IS THE MOTHER OF MASTERY *
 *      PERSISTENTLY PATIENTLY YOU ARE BOUND TO SUCCEED         *
 ****************************************************************

Lecture Arrays:

if you initialize array like this: b := [...]string {"Saba", "Gela"}
compiler will guess how many values are there in the array with ... inside []
this is called literall

if arrays are different type like if one is string and other int or
if one of them is [2]int and other [3]int you can't use = operator on them

for example if array c %T is [4]int and array a %T is [3]int 
i can't do operation like c = a or vice versa

------------------------------------------------------------------
Lecture Slice:
you can add elements into slice using append function and inside 
append function you can add as many arguments as you want
for example: mySlice = append(mySlice, arg1, arg2, arg3, arg4 ...)

you delete element in slice also using append function and reslicing 
method
for example:
    a := []int {1, 2, 3, 4, 5}
    if i want to delete first element i will write
    a = append(a[:0], a[1:]...)

slice is built on top of array. Could be said that it is slice is referencing
its values
In internal of GO values are stored inside of an underlying array.
Slice is pointing towards that underlaying array. There is pointer
that says go look at that underlying array, that memory address where
those values are store and then geet the values from there.
Slice is struct. data structure for slice is pointer and it is writen
like this. 
type slice struct {
    array unsafe.Pointer
    len int
    cap int 
}

everytime we use make it is allocating memory in heap. make is type 
and unlike new, make return type is the same as the type of its 
argument not a pointer to it

if i have slice a and i type something like b := a
b is pointing to underlying array that a slice has so any modification
on those array from either slice(variable) will cause change for both
slice(variable). in order for that to not happen use function
copy(destination, source)
for example:
    a := []int{1, 2, 3, 4, 5}
    b := make([]int, 5)
    copy(b, a)

what is copy pointing towards??
    
-------------------------------------------------------------------
maps
if you want to delete from map we need to use 
func delete(map, key)

tu mapidan iseti elemntis washal sheecdebi romelic ar arsebobs an ramdenime
xnis win washale, aranairi errori ar moxdeba da compileri ar chavardeba
panikashi da ar getyvis ras aketeb shig ho ar gaqo mokled

tu mapis value aris int da key ar arsebobs is 0-s daabrunebs

comma okay idiom
--------------------------------------------------------------------
Functions

tip: if you are comming for other languages such as me from c++
drop terminology like pass by value pass by reference
when you pass a value as an argument to a function, it's going to assign
that value to a variable, to an identifier. argument is passed
by value

if i want to create function with unlimited parameter it should look
something like this:
func sum(ii ...int){} 
if you use %T on argument that is passed in this function you will 
see that it is actually slice of int []int. search Variadic with
ctrl + f inside go doc to see more
this variadic parameter ... needs to be last obviously. you can pass
other arguments normally if you like behind variadic parameter
Note: variadic parameter ... also accepts 0 parameters


defer statement doesn't run the function till the outer surrounding 
function exits and does it's thing

when you write identifie for function for example
func (p Person) speak() it almost adds it in that struct like
this function was written inside that Person struct like you write
methods in c++ and other oop languages. so if i want to call that func
i will call it like p.speak() and not just speak(). If function has
reciever it is called method.

Interfaces allow us to have polymorphysm which means that one value,
which is of a certain type, can also be of another type

Interface rizz be like: hey babe if you got these methods you are my type

Stringer interfece be working like:
any type that has method with returns string eg
type Stringer interface {
    String() string
}
is stringer
if you want to adjust how the default printin is of stuff,
you can implement the stringer interface


wrapper is a function that provides and additional layer
of abstraction of functionality around an existing function or
method. it allows you to modify inputs, outpus, or behaviour
of funciton without directly modifying it

we also have writer interface. any type that implemets this method
Write(p []byte) (n int, err error) is a Writer interface
writer interface looks like this:
type Writer interface {
    Write(p []byte) (n int, err error)
}

creating files be like:
first of all we need "os" package to be included
to create file i need to use os.Create("file.txt") function:
os.Create("output.txt") which returns file and error
in order to writen in file i need:
Write(b []byte) function which returns int and error

what is the difference between string and slice of bytes?
first of all they are different types, but they are closely related
and can often be converted betweem each other
A string in go represents a sequence of characters. it is an
immutable type, which means you can't modify individual characters
inside string. string values are always interpreted as UTF-8 
encoded Unicode text.
[]byte is slice of bytes, where each element represents single byte.
It is mutable type, so you can modify individual bytes within a byte
slice. It can be used to represent binary data or text in various
encoding
examples of converting these types
string to a byte slice:
bytes := []byte(str)
byte slice to a string
str := string(bytes)
IMPORTENT:converting between strings and byte slices involves encoding
and decoding operations, which can indroduce potential errors if encoding
is not handeled correctly. be maindful of the encoding.

byte buffer is a region of memory used to temporarily store a 
sequence of bytes. it is useful for tasks like 
data serialization, network communication, file I\O, and efficient
string manipulation.
A byte buffer is a data structure that provides a convenient interface
to manipulate sequences of byte efficiently. It serves a a temporary
storage for byte data and enables operations such as reading, writing,
appending, and resizing byte sequences.
(Find more info on this from course outline from page 75 +-2)
if you want to create buffer you do that like this:
b := bytes.NewBufferString("Hello")
if you want to print that buffer you do this:
fmt.Println(b.String())
if you want to write in buffer you use this function:
b.WriteString("Ghopers!")
if you want to reset buffer you use this function:
b.Reset()
you can write in buffer also like this:
b.Write([]byte("happy happy haaapppyyy"))
buffer implements the writer interface

NOTE: Functions are type in go meaning we can assign functions to
variables

we can return functions and we can pass funtcion as an argument

Callback is when you pass function as an argument

Hands-on-Exercise #67 return to this every day and try to rewrtire
code that is in it


why do we use anonymous functions. what is the main reason for it?
Anonymous funcs are commonly used when you want to pass a function 
as an argument to another function or when you need to 
define a short-lived function for a specific task.

-----------------------------------------------------------------------
//es da zemot funqciebi unda wavikitxo yovel dge rata kargad gajdes tvinshi

Pointers

In Go reference type is pointer
Go has several reference types which are: pointers, slices, maps,
functions, interfaces and channels

NOTE: when you assign a reference type to another variable, the new variable references the same memory location

In Go, all data is passed by value, which means that whenever you pass data to a function, Go
creates a copy of that data and assigns the copy to a parameter variable. The function can do
whatever it wants to the copy without affecting the original data

A mutable value is a value that can be changed. In Go, slices, maps, and pointers are
mutable data types. Even though they are passed by value, they still behave as if they were
passed by reference because the "value" that is copied and passed is the reference to the
underlying data, not the actual data in case of slice it is underlaying array

Since everything in Go is passed as a value pointer is also passed as a value and is no exception to the rule. This means that function get copy of the address. Therefore, dereferencing the pointer and
modifying the value it points to inside the function will modify the original value.

In summary, in Go, everything is passed by value. However, for mutable data types, the
"value" that's passed includes a reference to the underlying data, which is why changes
made inside the function are visible outside of it.

Pointer and value semantics
Pointer semantics in Go, involve passing the memory address (a "pointer")
rather than the data itself. This means that you can modify the original data, not just a copy of
it

Value semantics are simpler and often safer because they avoid side effects, but
they can be inefficient for large data structures because they involve copying data

GUIDELINES to follow whether to use pointer or value semantics

1.Use Value Semantics When Possible:
● Value semantics are simpler and usually safer, since they don't involve shared state
or require you to think about memory management.

● rule of thumb, if a function doesn't need to modify its input, or the data you're working
with is small (like built-in types or small structs), use value semantics. s

● rule of thumb: use value semantics for builtin types (numeric, string, bool) and

reference types (slices, maps, channels, pointer, interfaces, functions)

2. Use Pointer Semantics for Large Data:
● Copying large structs or arrays can be inefficient.

● If the data you're working with is large, you might want to use pointer semantics to
avoid the cost of copying the data. A rule of thumb: 64 bytes or larger, use pointers.

3. Use Pointer Semantics for Mutability:
● If a function or method needs to modify its receiver or an input parameter, you'll need
to use pointer semantics.

● This is a common use case for methods that need to update the state of a struct.

4. Consistency:
● It's important to be consistent. If some functions on a type use pointer semantics and
others use value semantics, it can lead to confusion. Typically, once a type has a
method with pointer semantics, all methods on that type should have pointer
semantics.

5. Pointer Semantics When Interfacing With Other Code:
● If you're interfacing with other code (like a library or a system call), you might need to
use pointer semantics. For example, the `json.Unmarshal` function in the Go standard
library requires a pointer to a value to populate it with unmarshalled data

VALUE SEMANTICS
value semantics facilitate higher levels of integrity
"the majority of bugs that we get in software have to do with the
mutation of memory" ~ Bill Kennedy
everybody gets their own copy of the data (pass by value) helps
keep data bug free
● if everybody is isolated to their own copy of the data (pass
by value) then the bug is isolated to that one piece of code
○ value semantics also reduce side-effects around concurrency
○ more likely to keep values on the stack
○ you can have methods that use pointers if there's some form of unmarshaling
going on

POINTER SEMANTICS
you don’t want to pass around a lot of data
you want to change the data at a location (mutability)

Remember: the decision of using pointer or value semantics should be more about
sharing and mutating state rather than memory allocation and performance

The idea of the method set is integral to how interfaces are implemented and used in Go.
An interface in Go defines a method set, and any type whose method set is a superset of the
interface's method set is considered to implement that interface
if you define a method with a pointer receiver, the
method is only in the method set of the pointer type. This is important in the context of
interfaces because if an interface requires a method that's defined on the pointer (not the
value), then you can only use a pointer to that type to satisfy the interface, not a value of the
type.

questions I need to answert to provet to my self that I understand these concepts
1. In go what is referece type? list the reference types
2. What happens when you assign a reference type to another variable?
3. In Go how is data passed? and what does it do
4. What is mutable value ? list mutable data types. how do this data types behave when they are passed?
5. when pointer is passed in functoin how is it passed and what does the function get? what will happen to original value if i modify pointer inside the function?
6. Describe Pointer and Value semantics
7. What are the GUIDELINES of using either Pointer or Value semantics?
8. What are rule of thumb of using Value semantics?
9. Which semantic do I need to use when i'm interfecing with other code?
and what does interfecing with other code mean?
10. Benefits of using Value Semantics and Pointer Semantics.
11. when making decision on which semantic to use what should i remember?
12. Which semantic kinda has to be default? and why
13. If i use pointer semantics what are values more likely to do ?
14. What command or so to say flag can i use to check whether value escpaes heap or not?
15. What are method sets and why are they important?
answer these question every day till I go to Germany.
Read Pointer section at least 3 times in couser_outline folder.
Look into Follow-Lecture -> pointers -> method-sets dir pretty important stuff is written there about method-sets
--------------------------------------------------------------------------
Generics:

Generics allow us to abstract our code and make it more DRY(Do not Repeat Yourself)

syntax for creating generic function of type T that accepts values i want
in this case int and float64
func addT[T int | float64](){

}

type set interface allows us to abstract our generic functions even more eg 
type mynumbers interface {
	int | float64
}

// abstract previously ussed addT function with interface
func addT[T mynumbers](a, b T) T {
	return a + b
}

Type alliases and underlying type constraints

if i add ~ behind the type for example int it tells compiler to include all values of that type in my example of type int
type mynumbers interface {
	~int | ~float64
}

// abstract previously ussed addT function with interface
func addT[T mynumbers](a, b T) T {
	return a + b
}

type myAlias int

func main() {
	var n myAlias = 22
	fmt.Println(addT(n, 2))
	fmt.Println(addT(1.2, 2.2))
}
this won't work without ~int inside myNumbers interface

package constraint

comparable is any type that can be compared like int, boolean, string etc


concrete type vs interface type

what is concrete type ?
concrete type is a type that you can directly instantie or create from. This means that type can directly represent a set of values and that you can create an instance of this type without any additional information.
concrete type examples: int, bool, string, float64, slices, maps, structs

interface type is abstract. they represent behaviour or type but not a specific set of values
------------------------------------------------------------------------
Json
cool websites:
https://rawgit.com
https://mholt.github.io/json-to-go/
godoc.org   // check this out and try to understand code that is written behing the function like fmt.Println and function I use from go standard library in general. Check indexes in Package io and stuff like that

use marshal to turn your data into json and use unmarshal to 
use that data into Go or any language

Need to find out about Encode and Decode

Writer interface is real important shit
if i have Writer interface i can pass that to NewEncode function which
give me pointer to Encoder *Encoder. I can then use that *Encoder
to Encode shit

Reader interface is also important shit

Learn about Sort interface from godoc

for sorting stuff just check directory inside 
Follow-Lecture > Json > sort or customSort

bcrypt
is an excellent way to store a password information. as soon as u get user password u encrypt it with bcrypt and even you don't know what the password is. Generally you never store password you only store encrypted version of it.
inside go docs you can search bcrypt

